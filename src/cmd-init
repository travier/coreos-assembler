#!/usr/bin/env bash
set -euo pipefail

dn="$(dirname "$0")"
# shellcheck source=src/cmdlib.sh
. "${dn}/cmdlib.sh"

# Initialize FORCE to 0 and BRANCH/COMMIT to an empty string
FORCE=0
BRANCH=""
COMMIT=""
TRANSIENT=0

SOURCE=""
VARIANT=""

print_help() {
    cat 1>&2 <<'EOF'
Usage: coreos-assembler init --help
       coreos-assembler init [--force] [--transient] [--branch BRANCH]
                             [--commit COMMIT] [-V/--variant VARIANT] GITCONFIG

  For example, you can use https://github.com/coreos/fedora-coreos-config as
  GITCONFIG, or fork it.

  Another option useful for local development (if you're running a shell inside
  this container) is to pass a file path starting with `/` - a symlink to it
  will be created and then used directly.

  You can specify a branch of a git repo with the `--branch` flag.

  Use `--transient` for builds that will throw away all cached data on
  success/failure, and should hence not invoke `fsync()` for example.

  In the default case, a config repo only includes the configuration for a
  single variant and the following files are thus used:
    - `manifest.yaml`
    - `image.yaml`
    - `extensions.yaml`

  If you want to include multiple variants in a single repo, you will have to
  provide configuration files that specify for each variant which suffix to use
  for the following files:
    - `manifest-$VARIANT.yaml`
    - `image-$VARIANT.yaml`
    - `extensions-$VARIANT.yaml`
  The configuration files should only include the suffix (usualy a version) on
  a single line.

  For example, for the `scos` variant, the `variant_scos` file will be;
  ```
  $ cat variant_scos
  c9s
  ```
  and the following files will be used:
    - `manifest-c9s.yaml`
    - `image-c9s.yaml`
    - `extensions-c9s.yaml`

  The two step process (configuration files specifying a version) is required
  to enable developers and CI to track a variant (RHCOS, SCOS) independently of
  the version of the base operating system used to build it (C9S, C10S, RHEL
  8.6, RHEL 9.0, etc.). It is thus recommended to provide both explicit
  versioned variants (c9s, rhel-8.6, rhel-9.0) and generic ones (scos, rhcos).
EOF
}

# Call getopt to validate the provided input.
rc=0
options=$(getopt --options hfb:c:V: --longoptions help,force,transient,branch:,commit:,variant: -- "$@") || rc=$?
[[ $rc -eq 0 ]] || {
    print_help
    exit 1
}
eval set -- "$options"
while true; do
    case "$1" in
    -h | --help)
        print_help
        exit 0
        ;;
    -f | --force)
        FORCE=1
        ;;
    --transient)
        TRANSIENT=1
        ;;
    -b | --branch)
        case "$2" in
            "")
                shift ;;
            *)
                BRANCH="$2"
                shift ;;
        esac
        ;;
    -c | --commit)
        case "$2" in
            "")
                shift ;;
            *)
                COMMIT="$2"
                shift ;;
        esac
        ;;
    -V | --variant)
        case "$2" in
            "")
                shift ;;
            *)
                VARIANT="$2"
                shift ;;
        esac
        ;;
    --)
        shift
        break
        ;;
    *)
        print_help
        fatal "init: unrecognized option: $1"
        exit 1
        ;;
    esac
    shift
done

case "$#" in
    0)
        # If user did not provide a repo then error out
        print_help
        fatal "ERROR: Missing GITCONFIG"
        exit 1
        ;;
    1)
        SOURCE="$1"
        ;;
    *)
        print_help
        fatal "ERROR: Too many arguments"
        exit 1
        ;;
esac

# If the current working dir is not empty then error out unless force provided
if [[ "$FORCE" != "1" ]] && [[ -n "$(ls ./)" ]]; then
   fatal "init: current directory is not empty, override with --force"
fi

preflight

if has_privileges; then
    sudo chown "$USER:" .
elif [[ ! -w . ]]; then
    fatal "init: running unprivileged, and current directory not writable"
fi

set -x
# Initialize sources (git)
mkdir -p src
(cd src
 if [[ ! -e config ]]; then
     case "${SOURCE}" in
         /*) ln -s "${SOURCE}" config
             ;;
         # The $BRANCH variable below is explicitely unquoted as we rely on it
         # being skipped if empty
         *) git clone ${BRANCH:+--branch=${BRANCH}} --depth=1 --shallow-submodules --recurse-submodules "${SOURCE}" config
            # If a commit was specified then we'll fetch and reset
            # the specified branch to that commit. This is useful when
            # doing pipeline builds and targetting a specific commit
            # (i.e.) subordinate multi-arch build pipelines running
            # cosa init later in time than the x86_64 pipeline; new
            # commits could have come in.
            if [ -n "${COMMIT}" ]; then
                git -C ./config fetch origin "$COMMIT"
                git -C ./config reset --hard "$COMMIT"
            fi
            (set +x; cd config && echo -n "Config commit: " && git describe --tags --always --abbrev=42)
            ;;
     esac
 fi)

# Setup the config for a given variant
setup_variant() {
    if [[ "${#}" -ne 1 ]]; then
        echo 1>&2 "Error: This function must be called with the variant name to validate"
    fi

}

# If no variant is selected:
#   - Ensure that we have a manifest and an image definition to build an ostree
#     commit and image from the config in the repo.
#   - If no default manifest and image definition is available, look for a
#     default variant.
# Otherwise, setup the variant as explicitely requested.
 if [[ -z "${VARIANT}" ]]; then
    manifest="src/config/manifest.yaml"
    image="src/config/image.yaml"
    if [[ -f "${manifest}" ]] && [[ -f "${image}" ]]; then
        echo "Using default manifests (${manifest} & ${image})"
    elif [[ ! -f "${manifest}" ]] && [[ ! -f "${image}" ]]; then
        echo "Could not find the default manifests (${manifest} & ${image}). Looking for a 'default' variant (src/${variant_file})"
        setup_variant "default"
    fi
 # If we have requested a specifc variant then use that.
 else
    validate_variant "${VARIANT}"
 fi
local -r variant="${1}"

local -r variant_file="config/variant_default"
        if [[ ! -f "${variant_file}" ]]; then
            echo 1>&2 "Could not find a default manifest (src/${manifest}) or a default variant (src/${variant_file})"
            fatal "If you are using a custom configuration, be sure it has a manifest.yaml."
        else
            osver="$(head -1 "${variant_file}")"
            if [[ ! -f "${variant_file}" ]]; then
                echo 1>&2 "Could not find a default manifest (src/${manifest}) or a default variant (src/${variant_file})"
                fatal "If you are using a custom configuration, be sure it has a manifest.yaml."
            echo "Using variant: ${VARIANT} (${osver})"
            cat > "config.json" <<EOF
{
"coreos-assembler.variant": "${VARIANT}"
}
EOF
        fi

     variant_file="config/variant_${VARIANT}"
     if [[ ! -f "${variant_file}" ]]; then
         fatal "Could not find the requested variant: ${VARIANT} (src/${variant_file})"
     else
        osver="$(head -1 "${variant_file}")"
        echo "Using variant: ${VARIANT} (${osver})"
        echo "${osver}" > "osver"
     fi

mkdir -p cache
mkdir -p builds
mkdir -p tmp
mkdir -p overrides/rpm
mkdir -p overrides/rootfs

if [[ "${TRANSIENT}" == 1 ]]; then
    touch tmp/cosa-transient
fi

set +x
echo "Initialized $PWD as coreos-assembler working directory."
