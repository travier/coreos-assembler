#!/usr/bin/env bash
set -euo pipefail

dn="$(dirname "$0")"
# shellcheck source=src/cmdlib.sh
. "${dn}/cmdlib.sh"

# Initialize FORCE to 0 and BRANCH/COMMIT to an empty string
FORCE=0
BRANCH=""
COMMIT=""
TRANSIENT=0

SOURCE=""
VARIANT=""

print_help() {
    cat 1>&2 <<'EOF'
Usage: coreos-assembler init --help
       coreos-assembler init [--force] [--transient] [--branch BRANCH]
                             [--commit COMMIT] [-V/--variant VARIANT] GITCONFIG

  For example, you can use https://github.com/coreos/fedora-coreos-config as
  GITCONFIG, or fork it.

  Another option useful for local development (if you're running a shell inside
  this container) is to pass a file path starting with `/` - a symlink to it
  will be created and then used directly.

  You can specify a branch of a git repo with the `--branch` flag.

  Use `--transient` for builds that will throw away all cached data on
  success/failure, and should hence not invoke `fsync()` for example.

  In the default case, a config repo only includes the configuration for a
  single variant and the following files are thus used:
    - `manifest.yaml`
    - `image.yaml`
    - `extensions.yaml`

  If those files are not present in the repo of if a variant is explicitely
  specified with `cosa init --variant FOO ...`, then COSA will read the
  `variant_FOO` file (using `variant_default` if no variant is specified) to
  figure out the `VARIANT` suffix to use for the following files:
    - `manifest-$VARIANT.yaml`
    - `image-$VARIANT.yaml`
    - `extensions-$VARIANT.yaml`
EOF
}

# Call getopt to validate the provided input.
rc=0
options=$(getopt --options hfb:c:V: --longoptions help,force,transient,branch:,commit:,variant: -- "$@") || rc=$?
[[ $rc -eq 0 ]] || {
    print_help
    exit 1
}
eval set -- "$options"
while true; do
    case "$1" in
    -h | --help)
        print_help
        exit 0
        ;;
    -f | --force)
        FORCE=1
        ;;
    --transient)
        TRANSIENT=1
        ;;
    -b | --branch)
        case "$2" in
            "")
                shift ;;
            *)
                BRANCH="$2"
                shift ;;
        esac
        ;;
    -c | --commit)
        case "$2" in
            "")
                shift ;;
            *)
                COMMIT="$2"
                shift ;;
        esac
        ;;
    -V | --variant)
        case "$2" in
            "")
                shift ;;
            *)
                VARIANT="$2"
                shift ;;
        esac
        ;;
    --)
        shift
        break
        ;;
    *)
        print_help
        fatal "init: unrecognized option: $1"
        exit 1
        ;;
    esac
    shift
done

case "$#" in
    0)
        # If user did not provide a repo then error out
        print_help
        fatal "ERROR: Missing GITCONFIG"
        exit 1
        ;;
    1)
        SOURCE="$1"
        ;;
    *)
        print_help
        fatal "ERROR: Too many arguments"
        exit 1
        ;;
esac

# If the current working dir is not empty then error out unless force provided
if [[ "$FORCE" != "1" ]] && [[ -n "$(ls ./)" ]]; then
   fatal "init: current directory is not empty, override with --force"
fi

preflight

if has_privileges; then
    sudo chown "$USER:" .
elif [[ ! -w . ]]; then
    fatal "init: running unprivileged, and current directory not writable"
fi

set -x
# Initialize sources (git)
mkdir -p src
(cd src
 if [[ ! -e config ]]; then
     case "${SOURCE}" in
         /*) ln -s "${SOURCE}" config
             ;;
         # The $BRANCH variable below is explicitely unquoted as we rely on it
         # being skipped if empty
         *) git clone ${BRANCH:+--branch=${BRANCH}} --depth=1 --shallow-submodules --recurse-submodules "${SOURCE}" config
            # If a commit was specified then we'll fetch and reset
            # the specified branch to that commit. This is useful when
            # doing pipeline builds and targetting a specific commit
            # (i.e.) subordinate multi-arch build pipelines running
            # cosa init later in time than the x86_64 pipeline; new
            # commits could have come in.
            if [ -n "${COMMIT}" ]; then
                git -C ./config fetch origin "$COMMIT"
                git -C ./config reset --hard "$COMMIT"
            fi
            (set +x; cd config && echo -n "Config commit: " && git describe --tags --always --abbrev=42)
            ;;
     esac

     # Setup the variant as requested or use the default.
     # If no variant have been explicitely selected, then we need a default
     # manifest or a default_variant file to be present.
     if [[ -z "${VARIANT}" ]]; then
        manifest="config/manifest.yaml"
        if [[ -f "${manifest}" ]]; then
            echo "Using default manifest (src/${manifest})"
        else
            variant_file="config/variant_default"
            if [[ ! -f "${variant_file}" ]]; then
                echo 1>&2 "Could not find a default manifest (src/${manifest}) or a default variant (src/${variant_file})"
                fatal "If you are using a custom configuration, be sure it has a manifest.yaml."
            else
                osver="$(head -1 "${variant_file}")"
                echo "Using variant: ${VARIANT} (${osver})"
                echo "${osver}" > "osver"
            fi
        fi
     # If we have requested a specifc variant then use that.
     else
         variant_file="config/variant_${VARIANT}"
         if [[ ! -f "${variant_file}" ]]; then
             fatal "Could not find the requested variant: ${VARIANT} (src/${variant_file})"
         else
            osver="$(head -1 "${variant_file}")"
            echo "Using variant: ${VARIANT} (${osver})"
            echo "${osver}" > "osver"
         fi
     fi
 fi)

mkdir -p cache
mkdir -p builds
mkdir -p tmp
mkdir -p overrides/rpm
mkdir -p overrides/rootfs

if [[ "${TRANSIENT}" == 1 ]]; then
    touch tmp/cosa-transient
fi

set +x
echo "Initialized $PWD as coreos-assembler working directory."
